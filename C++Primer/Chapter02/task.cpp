/*
第二章的章节练习:
2.1 int, long, long long和short的区别? 有无符号类型的区别? float和double的区别?
	short为短整型, 占16位
	int为整型, 占16位
	long, long long为长整型, 分别占32位, 62位
	无符号: 仅能表示大于等于0的值, 所有比特都用来存储数值
	有符号: 可以表示正数, 负数, 0, 最高位(符号位)为1时, 表示为负值; 为0时, 表示为正值
	float: 单精度浮点型, 占32位, 6位有效数字
	double: 双精度浮点型, 占64位, 10位有效数字
2.19指针和引用的区别
	指针: 是一个对象, 存放某个对象的地址, 可以对其赋值和拷贝, 无需对其赋初值
	引用: 不是对象, 相当于给某对象起别名, 无法重新绑定另外的对象, 必须赋初值

const限定符:
	1. const对象无法赋值, 必须被初始化
	2. 只能在const类型的对象上执行不改变其内容的操作
	3. 默认状态下, const对象仅在文件内有效(若想在多个文件间共享const对象, 必须在定义前加extern)
	4. 常量不能被赋值, 非常量不能->常量
对const的引用(常量引用):
	1. 不能被用作修改其所绑定的对象
	2. 普通引用类型必须与其引用对象的类型一致
	3. 常量引用可以绑定(初始化)非常量的对象, 字面量, 一般表达式
	4. 常量引用绑定另一种类型, 相当于绑定到临时变量上
	5. 非常量引用无法指向一个常量对象(无法赋值, 故不能用非常量引用)
	6. 常量引用可以绑定一个非常量, 只是不允许通过其修改绑定对象的值
	7. 引用本身非对象, 无法让其恒定不变	
2.26
	const int cnt;		错误, const对象必须被初始化
	const int sz = cnt;	正确
	++cnt		正确, 变量递增操作
	++sz		错误, 无法通过常量引用修改值
	
指向常量的指针:
	1. 不能用作改变其所指对象的值
	2. 普通指针类型必须与所指对象的类型一致
	3. 指向常量的指针可以指向一个非常量对象
const指针:
	1. 指针本身是常量, 将一直指向某对象
2.27
	int i = -1, &r = 0;		错误, 非常量引用无法引用字面值常量
	int *const p1 = &i;		正确, 常量指针永远指向i
	const int i = -1, &r = 0;	正确, 常量引用可以绑定字面量
	const int *const p2 = &i;	正确, 常量指针永远指向i, 且无法通过p2修改所指对象的值
	const int i2 = i, &r = i;	正确, 初始化值为i的常量i2; 常量引用r无法改变i的值
	const int &const r2;		错误, 引用本身非对象, 无法让其恒定不变
2.28
	int i, *p1, *const p2;		错误, 常量指针p2必须初始化
	const int ic, &r = ic;		错误, 常量ic必须初始化
	const int *const p3;		错误, 常量指针p3必须初始化, 且无法通过p3修改所指对象的值
	const int *p;				正确, 但p没有指向任何实际的对象
2.29
	i = ic;				正确, 常量ic的值赋给非常量i
	p1 = p3; p1 = &ic;	错误, 普通指针无法指向常量p3, ic; 
	p2 = p1; p3 = p2; ic = &p3;	错误, 常量无法被赋值
	
顶层const: 指针本身是常量, 拷贝不受影响
底层const: 指针所指对象是常量, 拷入拷出必须具有相同的底层const资格
	int i = 0;
	int *const p1 = &i;			本身是常量, 顶层const
	const int ci = 42;			本身是常量, 顶层const
	const int *p2 = &ci;		所指对象是常量, 底层const
	const(底层) int *const p3(顶层) = p2;
	const int &r = ci;			用于声明引用的const都是底层const
	
	i = ci;		正确, 顶层const不影响拷贝
	p2 = p3;	正确, p2, p3指向对象类型相同(const int), p3顶层const不影响拷贝
	
	int *p = p3;	错误, p3有底层const定义, 而p没有(普通指针无法指向常量)
	p2 = p3;		正确, 都是底层const
	p2 = &i;		正确, int*可以转换成const int*
	int &r = ci;	错误, 非常量指针无法绑定常量
	const int &r2 = i;	正确, 常量引用可以绑定非常量
2.30
	const(顶层) int v2 = 0; int v1 = v2;
	int *p1 = &v1, &r1 = v1;
	const(底层) int *p2 = &v2, *const(顶层) p3 = &i, &r2(底层) = v2;
2.31
	r1 = v2;	正确, 顶层const不影响拷贝
	p1 = p2;	错误, 不具有相同的底层const, 普通指针无法指向常量
	p2 = p1;	正确, 常量指针可以指向非常量, 但无法通过p2修改所指对象的值
	p1 = p3;	错误, 普通指针无法指向常量
	p2 = p3;	正确, 具有相同的const

constexpr: 将变量声明为该类型, 以便由编译器来检验变量的值是否为常量表达式
	1. 常量表达式: 值不会改变并且在编译过程就能得到计算结果的表达式
	2. constexpr函数: 应足够简单以使编译时就可以计算其结果
	3. 指针和引用: 初始值必须是nullptr/0/固定地址中的对象
	   (函数体内定义的变量非固定, 所有函数体外的对象地址固定不变)
auto: 让编译器通过初始值来推算变量的类型
	1. 使用auto声明多个变量, 一条语句中所有变量的初始类型必须一样
	2. 以引用对象的类型作为auto的类型
	3. auto一般会忽略顶层const, 保留底层const
decltype: 选择并返回操作数的类型
	1. 引用从来都作为其所指对象的同义词出现, 只有在decltype中例外
	2. 给变量加上括号后, 编译器会把其当作表达式
	3. 双层括号的结果永远是引用, 而无括号仅当变量本身是引用是才是引用
*/
