//由顶点的有穷非空集合和顶点之间边的集合组成 G(V, E)
//不允许无顶点, 边集可为空
/*五种存储结构 (n个顶点和e条边)
邻接矩阵: 用两个数组		O(n^2+n+e)
	1个一维数组存储图中顶点信息
	1个二维数组(邻接矩阵)存储图中边或弧的信息
邻接表: 数组和链表相结合	O(n+e)
	1个一维数组存储顶点信息(每个数据元素还需存储指向第一个邻接点的指针)
	1个单链表存储每个顶点的所有邻接点
十字链表: 相当于将邻接表和逆邻接表整合在一起
邻接多重表: 相比于十字链表, 同一条边在邻接表中只有1个结点

深度优先遍历(递归过程, 相当于树的前序遍历):
1.从某个顶点v出发, 访问此顶点
2.从v的未被访问的邻接点出发深度优先遍历图, 直至图中所有和v有路径相通的顶点都被访问到
3.若图中尚有顶点未被访问, 则另选图中1个未曾被访问的顶点作为起点
4.重复上述过程, 直至图中所有顶点都被访问到

广度优先遍历(相当于树的层序遍历)
*/

/*
ADT 图(Graph)
Data
	顶点的有穷非空集合和边的集合
Operation
CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G
DestroyGraph(*G): 图G存在则销毁
LocateVex(G, u): 若图G中存在顶点u, 则返回图中的位置
GetVex(G, v): 返回图G中顶点v的值
PutVex(G, v, value): 将图G中顶点v赋值value
FirstAdjVex(G, *v): 返回顶点v的1个邻接顶点
NextAdjVex(G, v, *w): 返回顶点v相对于顶点w的下一个邻接顶点
InsertVex(*G, v): 在图G中增添新顶点v
DeleteVex(*G, v): 删除图G中顶点v及相关的边
InserArc(*G, v, w): 在图G中增添弧<v, w>, 若G为无向图, 还需增添对称弧<w, v>
DeleteArc(*G, v, w): 在图G中删除弧<v, w>, 若G为无向图, 还需删除对称弧<w, v>
DFSTraverse(G): 对图G中进行深度优化遍历, 在遍历过程中对每个顶点调用
HFSTraverse(G): 对图G中进行广度优先遍历, 在遍历过程中对每个顶点调用
endADT
*/
